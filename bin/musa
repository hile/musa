#!/usr/bin/env python
"""
Music tagging command
"""

import os,sys,shutil

from musa.cli import MusaScript,MusaCommand
from musa.tree import Tree,Album,Track,TreeError
from musa.tags import TagError
from musa.prefixes import TreePrefixes
from musa.metadata import CoverArt
from musa.transcoder import MusaTranscoder,TranscoderError
from musa.tags.albumart import AlbumArt,AlbumArtError

class AlbumArtCommand(MusaCommand):
    def __init__(self,script):
        MusaCommand.__init__(self,script,'albumart','Manage music file album art')
        self.parser.add_argument('-e','--embed',action='store_true',
            help='Embed artwork file'
        )
        self.parser.add_argument('-x','--extract',action='store_true',
            help='Extract artwork file'
        )
        self.parser.add_argument('-i','--info',action='store_true',
            help='Artwork files info'
        )
        self.parser.add_argument('-u','--url',
            help='Fetch artwork from given url'
        )
        self.parser.add_argument('paths', metavar='path', nargs='*',
            help='Paths to process'
        )

    def show_info(self,target):
        if isinstance(target,Track):
            tags = self.get_tags(target)
            if tags is None or not tags.supports_albumart:
                return
            try:
                albumart = tags.albumart
            except AlbumArtError,emsg:
                return
            print '%s: %s' % (coverart.path,albumart)

        elif isinstance(target,Tree):
            for album in target.as_albums():
                album.load()
                for m in album.metadata:
                    if isinstance(m,CoverArt):
                        self.print_coverart_info(m)
                    else:
                        print m

    def print_coverart_info(self,coverart):
        albumart = AlbumArt(coverart.path)
        print '%s: %s' % (coverart.path,albumart)

    def embed(self,target,albumart=None):
        if isinstance(target,Tree):
            albums = target.as_albums()
            if not albums:
                self.script.exit(1,'No albums found from path %s' % target.path)
            if len(albums)>1:
                print albums
                self.script.exit(1,'Albumart can only embedded to single album tree targets')
            album = albums[0]
            if albumart is None:
                albumart = album.albumart
            if albumart is None:
                return
            for track in album:
                tags = track.tags
                if tags is None:
                    continue
                tags.set_albumart(albumart)
                tags.save()
        elif isinstance(target,Track):
            if albumart is None:
                track_album = Album(os.path.dirname(target.path))
                albumart = track_album.albumart
            if albumart is None:
                return
            tags = target.tags
            if tags is None:
                return
            tags.set_albumart(albumart)
            #for k,v in tags.entry.items(): print k,v
            tags.save()

    def extract(self,target):
        if isinstance(target,Tree):
            albums = target.as_albums()
            if not albums:
                self.script.exit(1,'No albums found from path %s' % target.path)
            for album in albums:
                track = album[0]
                tags = track.tags
                if tags is None:
                    print 'No tags in %s' % track.path
                    continue
                if not tags.albumart:
                    print 'No album art in %s' % track.path
                    continue
                albumart_path = os.path.join(os.path.dirname(track.path),'artwork.jpg')
                print 'Saving %s: %s' % (albumart_path,tags.albumart)
                #tags.albumart.save(albumart_path)
        elif isinstance(target,Track):
            tags = target.tags
            if tags is None:
                print 'No tags in %s' % target.path
                return
            if not tags.albumart:
                print 'No album art in %s' % target.path
                return
            albumart_path = os.path.join(os.path.dirname(target.path),'artwork.jpg')
            print 'Saving %s: %s' % (albumart_path,tags.albumart)
            #tags.albumart.save(albumart_path)

    def parse_args(self,args):
        dirs,tracks,metadata = MusaCommand.parse_args(self,args)

        if args.info:
            for m in metadata:
                if not isinstance(m,CoverArt):
                    continue
                self.print_coverart_info(m)

            for tree in dirs:
                self.show_info(tree)

            for track in tracks:
                self.show_info(track)

        if args.url:
            albumart = AlbumArt()
            try:
                albumart.fetch(args.url)
            except AlbumArtError,emsg:
                self.script.exit(1,'Error fetching albumart: %s' % emsg)
            for target in dirs:
                albumart.save(target.path)
        else:
            albumart = None

        if args.embed:
            for tree in dirs:
                self.embed(tree,albumart)
            for track in tracks:
                self.embed(track,albumart)
        if args.extract:
            for tree in dirs:
                self.extract(tree)
            for track in tracks:
                self.extrack(track)

class CompareCommand(MusaCommand):
    def __init__(self,script):
        MusaCommand.__init__(self,script,'compare','Compare music files')

        self.parser.add_argument('paths', metavar='path', nargs='*',
            help='Paths to process'
        )

    def compare_trees(self,src,dst):
        print 'Tree compare not yet implemented'

    def compare_tracks(self,src,dst):
        if isinstance(src,basestring):
            try:
                src = Track(src)
            except TreeError,emsg:
                self.script.exit(1,emsg)
        if isinstance(src,basestring):
            try:
                dst = Track(dst)
            except TreeError,emsg:
                self.script.exit(1,emsg)
        print 'Comparing %s to %s' % (src.relative_path,dst.relative_path)
        src_tags = src.tags
        dst_tags = dst.tags

        for tag in sorted(src_tags.keys()):
            if tag not in dst_tags.keys():
                print '%s: missing %s' % (dst.relative_path,tag)

        for tag in sorted(dst_tags.keys()):
            if tag not in src_tags.keys():
                print '%s: missing %s' % (src.relative_path,tag)

        for tag in sorted(src_tags.keys()):
            if tag not in dst_tags.keys():
                continue
            if src_tags[tag] != dst_tags[tag]:
                print 'tag %s: %s != %s' % (tag,src_tags[tag],dst_tags[tag])

    def parse_args(self,args):
        dirs,tracks,metadata = MusaCommand.parse_args(self,args)

        if dirs and tracks:
            self.script.exit(1,"Can't compare trees to tracks")

        if dirs and len(dirs)==2:
            self.compare_trees(*dirs)
        elif tracks and len(tracks)==2:
            self.compare_tracks(*tracks)
        elif metadata:
            self.script.exit(1,'One of tracks was a metadata file')
        else:
            self.script.exit(1,'Requires two directory or file arguments')

class ConvertCommand(MusaCommand):
    def __init__(self,script):
        MusaCommand.__init__(self,script,'convert','Transcode file formats')
        self.prefixes = TreePrefixes()

        self.parser.add_argument('-t','--threads', type=int, default=1,
            help='Number of transcoder threads to use'
        )
        self.parser.add_argument('-m','--metadata', action='store_true',
            help='Copy album metadata'
        )
        self.parser.add_argument('-y','--dry-run', action='store_true',
            help='Only show which tracks would have been transcoded'
        )
        self.parser.add_argument('-f','--overwrite', action='store_true',
            help='Overwrite existing target files'
        )
        self.parser.add_argument('-c','--codec',
            help='Destination file format for tree mode'
        )
        self.parser.add_argument('paths', metavar='path', nargs='*',
            help='Paths to process'
        )

    def enqueue(self,src,dst):
        if isinstance(src,basestring):
            try:
                src = Track(src)
            except TreeError,emsg:
                self.script.exit(1,emsg)
        if isinstance(dst,basestring):

            try:
                dst = Track(dst)
            except TreeError,emsg:
                self.script.exit(1,emsg)

        src_album = Album(os.path.dirname(src.path))
        dst_album = Album(os.path.dirname(dst.path))
        if src_album.path not in self.metadata_paths_to_copy.keys():
            self.metadata_paths_to_copy[src_album.path] = (src_album,dst_album)

        if os.path.isfile(dst.path) and not self.overwrite:
            return

        try:
            self.transcoder.enqueue(src,dst)
        except TranscoderError,emsg:
            self.script.exit(1,emsg)

    def transcode_tree(self,src,dst=None,dst_codec=None):
        if not isinstance(src,Tree):
            self.script.exit(1,'Tree transcoding requires a source tree')
        if dst_codec is None and dst is None:
            self.script.exit(1,'Tree transcoding requires destination tree or codec name')

        for track in src:
            if dst_codec is not None:
                prefix = self.prefixes.match_extension(dst_codec,match_existing=True)
                if prefix is None:
                    self.prefixes.match_extension(dst_codec,match_existing=False)
            else:
                prefix = self.prefixes.match(dst.path,match_existing=True)
                if prefix is None:
                    prefix = self.prefixes.match(dst.path,match_existing=True)

            if prefix is not None:
                codec = prefix.extensions[0]
                dst_relpath = '%s.%s' % (os.path.splitext(track.relative_path)[0],codec)
                dst = Track(os.path.join(prefix.path,dst_relpath))
            else:
                self.script.exit(1,'Could not find codec matching tree')
            self.enqueue(track,dst)

    def copy_metadata(self,dry_run=False):
        for src_path,albums in self.metadata_paths_to_copy.items():
            src_album,dst_album = albums
            for m in src_album.metadata:
                dst_path = os.path.join(
                    dst_album.path,os.path.basename(m.path)
                )
                if dry_run:
                    print dst_path
                elif self.overwrite or not os.path.isfile(dst_path):
                    try:
                        shutil.copyfile(m.path,dst_path)
                    except OSError,(ecode,emsg):
                        self.script.exit(1,'Error writing %s: %s' % (dst_path,emsg))

    def parse_args(self,args):
        dirs,tracks,metadata = MusaCommand.parse_args(self,args)

        track_count = sum(len(d.files) for d in dirs) + len(tracks)
        if not track_count:
            self.script.exit(1,'No music files detected')

        self.transcoder = MusaTranscoder(args.threads,args.overwrite,args.dry_run)
        self.overwrite = args.overwrite

        self.metadata_paths_to_copy = {}
        if len(dirs)==1 and args.codec is not None:
            self.transcode_tree(*dirs,dst_codec=args.codec)
        elif len(dirs)==2:
            self.transcode_tree(*dirs)
        elif len(tracks)==2:
            self.enqueue(*tracks)

        if len(self.transcoder):
            self.transcoder.run()
        else:
            self.script.log.debug(0,'Nothing to transcode')

        if args.metadata:
            self.copy_metadata(args.dry_run)

class SyncCommand(MusaCommand):
    def __init__(self,script):
        MusaCommand.__init__(self,script,'sync','Copy tags, files and trees')
        self.parser.add_argument('paths', metavar='path', nargs='*',
            help='Paths to process'
        )

    def parse_args(self,args):
        dirs,tracks,metadata = MusaCommand.parse_args(self,args)

        track_count = sum(len(d.files) for d in dirs) + len(tracks)
        if not track_count:
            self.script.exit(1,'No music files detected')

class TagsCommand(MusaCommand):
    def __init__(self,script):
        MusaCommand.__init__(self,script,'tags','Manage music file tags')

        self.parser.add_argument('-s','--set',action='append',
            help='Set tag from value (tag=value)'
        )
        self.parser.add_argument('-d','--delete',action='append',
            help='Delete tag'
        )
        self.parser.add_argument('-i','--input-file',
            help='Set new tags from input file'
        )
        self.parser.add_argument('-e','--edit',action='store_true',
            help='Edit tags in external editor'
        )
        self.parser.add_argument('-l','--list',action='store_true',
            help='List tags in given files'
        )
        self.parser.add_argument('-p','--print-path',action='store_true',
            help='Print file path before tags'
        )
        self.parser.add_argument('-P','--path-format',
            help='String format for --print-path flag'
        )
        self.parser.add_argument('paths', metavar='path', nargs='*',
            help='Paths to process'
        )

    def print_tags(self,track,print_path=False,path_format=None):
        if path_format is None:
            path_format = '### %s'

        tags = self.get_tags(track)
        if tags is None:
            return
        if print_path:
            print path_format % track.path
        for k,v in tags.items():
            print k,v

    def edit_tags(self,track):
        track_tags = self.get_tags(track)
        if track_tags is None:
            return None
        new_tags = self.script.edit_tags(track_tags.as_dict())
        if new_tags != track_tags.as_dict():
            try:
                if track_tags.replace_tags(new_tags):
                    track_tags.save()
            except TagError,emsg:
                self.script.exit(1,
                    'Error saving tags to %s: %s' % (track.path,emsg)
                )

    def update_tags(self,track,new_tags):
        track_tags = self.get_tags(track)
        if track_tags is None:
            return None
        try:
            if track_tags.update_tags(new_tags):
                track_tags.save()
        except TagError,emsg:
            self.script.exit(1,
                'Error saving tags to %s: %s' % (track.path,emsg)
            )

    def parse_args(self,args):
        dirs,tracks,metadata = MusaCommand.parse_args(self,args)

        track_count = sum(len(d.files) for d in dirs) + len(tracks)
        if not track_count:
            self.script.exit(1,'No music files detected')

        if args.set:
            tags = dict(map(lambda v: v.split('=',1), args.set))
            for target in dirs + tracks:
                if isinstance(target,Tree):
                    for track in target:
                        self.update_tags(track,tags)
                elif isinstance(target,Track):
                    self.update_tags(target,tags)

        elif args.delete:
            for target in dirs + tracks:
                if isinstance(target,Tree):
                    for track in target:
                        track.tags.remove_tags(args.delete)
                elif isinstance(target,Track):
                    target.tags.remove_tags(args.delete)

        elif args.edit:
            for target in dirs + tracks:
                if isinstance(target,Tree):
                    for track in target:
                        self.edit_tags(track)
                elif isinstance(target,Track):
                    self.edit_tags(target)

        else:
            for target in dirs + tracks:
                if isinstance(target,Tree):
                    for track in target:
                        self.print_tags(track,args.print_path,args.path_format)
                elif isinstance(target,Track):
                    self.print_tags(target,args.print_path,args.path_format)

class TreeCommand(MusaCommand):
    def __init__(self,script):
        MusaCommand.__init__(self,script,'tree','Manage music trees')

        self.parser.add_argument('-l','--list',action='store_true',
            help='List trees or files'
        )
        self.parser.add_argument('paths', metavar='path', nargs='*',
            help='Files to process'
        )

    def list_trees(self,dirs):
        for tree in dirs:
            print '%s: %d music files' % (tree.relative_path(),len(tree))

    def parse_args(self,args):
        dirs,tracks,metadata = MusaCommand.parse_args(self,args)

        track_count = sum(len(d.files) for d in dirs) + len(tracks)
        if not track_count:
            self.script.exit(1,'No music files detected')

        if tracks:
            self.script.exit(1,'File arguments are not accepted for tree commands')
        if not dirs:
            self.script.exit(1,'No directory paths detected')

        if args.list:
            self.list_trees(dirs)

script = MusaScript()
AlbumArtCommand(script)
CompareCommand(script)
ConvertCommand(script)
SyncCommand(script)
TagsCommand(script)
TreeCommand(script)
args = script.parse_args()

command = script.commands[args.command]
command.parse_args(args)

