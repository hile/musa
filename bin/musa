#!/usr/bin/env python
"""
Music tagging command
"""

import os,sys,shutil,argparse

from musa.cli import MusaScript,MusaCommand,MusaScriptError
from musa.tree import Tree,Album,Track,TreeError
from musa.tags import TagError
from musa.tags.xmltag import XMLTrackTree,XMLTagError

from musa.metadata import CoverArt
from musa.tags.albumart import AlbumArt,AlbumArtError

from musa.sync import SyncManager,SyncError
from musa.transcoder import MusaTranscoder,TranscoderError

class AlbumArtCommand(MusaCommand):
    def __init__(self,script):
        name = 'albumart'
        description = 'Manage music file album art'
        mode_flags = []

        MusaCommand.__init__(self,script,name,description,mode_flags)
        self.parser.add_argument('-e','--embed',action='store_true',help='Embed artwork file')
        self.parser.add_argument('-x','--extract',action='store_true',help='Extract artwork file')
        self.parser.add_argument('-i','--info',action='store_true',help='Artwork files info')
        self.parser.add_argument('-u','--url',help='Fetch artwork from given url')
        self.parser.add_argument('paths', metavar='path', nargs='*',help='Paths to process')

    def show_info(self,target):
        if isinstance(target,Track):
            tags = self.get_tags(target)
            if tags is None or not tags.supports_albumart:
                return
            try:
                albumart = tags.albumart
            except AlbumArtError,emsg:
                return
            self.message('%s: %s' % (coverart.path,albumart))

        elif isinstance(target,Tree):
            for album in target.as_albums():
                album.load()
                for m in album.metadata:
                    if isinstance(m,CoverArt):
                        self.print_coverart_info(m)
                    else:
                        self.message(m)

    def print_coverart_info(self,coverart):
        albumart = AlbumArt(coverart.path)
        self.message('%s: %s' % (coverart.path,albumart))

    def embed(self,target,albumart=None):
        if isinstance(target,Tree):
            albums = target.as_albums()
            if not albums:
                self.script.exit(1,'No albums found from path %s' % target.path)
            if len(albums)>1:
                self.script.exit(1,'Albumart can only embedded to single album tree targets')
            album = albums[0]
            if albumart is None:
                albumart = album.albumart
            if albumart is None:
                return
            for track in album:
                tags = track.tags
                if tags is None:
                    continue
                self.log.debug('embed: %s' % track.path)
                tags.set_albumart(albumart)
                tags.save()
        elif isinstance(target,Track):
            if albumart is None:
                track_album = Album(os.path.dirname(target.path))
                albumart = track_album.albumart
            if albumart is None:
                return
            tags = target.tags
            if tags is None:
                return
            self.log.debug('embed: %s' % target.path)
            tags.set_albumart(albumart)
            tags.save()

    def extract(self,target):
        if isinstance(target,Tree):
            albums = target.as_albums()
            if not albums:
                self.script.exit(1,'No albums found from path %s' % target.path)
            for album in albums:
                track = album[0]
                tags = track.tags
                if tags is None:
                    self.script.error('No tags in %s' % track.path)
                    continue
                if not tags.albumart:
                    self.script.error('No album art in %s' % track.path)
                    continue
                albumart_path = os.path.join(os.path.dirname(track.path),'artwork.jpg')
                self.log.debug('Saving %s: %s' % (albumart_path,tags.albumart))
                #tags.albumart.save(albumart_path)
        elif isinstance(target,Track):
            tags = target.tags
            if tags is None:
                self.script.error('No tags in %s' % target.path)
                return
            if not tags.albumart:
                self.script.error('No album art in %s' % target.path)
                return
            albumart_path = os.path.join(os.path.dirname(target.path),'artwork.jpg')
            self.log.debug('saving %s: %s' % (albumart_path,tags.albumart))
            tags.albumart.save(albumart_path)

    def parse_args(self,args):
        trees,tracks,metadata = MusaCommand.parse_args(self,args)

        if args.info:
            for m in metadata:
                if not isinstance(m,CoverArt):
                    continue
                self.print_coverart_info(m)

            for tree in trees:
                self.show_info(tree)

            for track in tracks:
                self.show_info(track)

        if args.url:
            albumart = AlbumArt()
            try:
                albumart.fetch(args.url)
            except AlbumArtError,emsg:
                self.script.exit(1,'Error fetching albumart: %s' % emsg)
            for target in trees:
                albumart.save(target.path)
        else:
            albumart = None

        if args.embed:
            for tree in trees:
                self.embed(tree,albumart)
            for track in tracks:
                self.embed(track,albumart)
        if args.extract:
            for tree in trees:
                self.extract(tree)
            for track in tracks:
                self.extrack(track)

class CompareCommand(MusaCommand):
    def __init__(self,script):
        MusaCommand.__init__(self,script,'compare','Compare music files')

        self.parser.add_argument('paths', metavar='path', nargs='*',help='Paths to process')

    def compare_trees(self,src,dst):
        src_track_paths = [x.relative_path.no_ext for x in src]
        dst_track_paths = [x.relative_path.no_ext for x in dst]
        if src_track_paths != dst_track_paths:
            print 'Filename mismatch'
            for s in src_tracks:
                print type(s.relative_path),s.relative_path.no_ext
        for track in src:
            if track.relative_path.no_ext not in dst_track_paths:
                print '%s: missing %s' % (dst.relative_path,track.relative_path.no_ext)
                continue

    def compare_tracks(self,src,dst):
        if isinstance(src,basestring):
            try:
                src = Track(src)
            except TreeError,emsg:
                self.script.exit(1,emsg)
        if isinstance(src,basestring):
            try:
                dst = Track(dst)
            except TreeError,emsg:
                self.script.exit(1,emsg)
        self.log.debug('Comparing %s to %s' % (src.relative_path,dst.relative_path))
        src_tags = src.tags
        dst_tags = dst.tags

        for tag in sorted(src_tags.keys()):
            if tag not in dst_tags.keys():
                self.script.error('%s: missing %s' % (dst.relative_path,tag))

        for tag in sorted(dst_tags.keys()):
            if tag not in src_tags.keys():
                self.script.error('%s: missing %s' % (src.relative_path,tag))

        for tag in sorted(src_tags.keys()):
            if tag not in dst_tags.keys():
                continue
            if src_tags[tag] != dst_tags[tag]:
                self.script.error('tag %s: %s != %s' % (tag,src_tags[tag],dst_tags[tag]))

    def parse_args(self,args):
        trees,tracks,metadata = MusaCommand.parse_args(self,args)

        if trees and tracks:
            self.script.exit(1,"Can't compare trees to tracks")

        if trees and len(trees)==2:
            self.compare_trees(*trees)
        elif tracks and len(tracks)==2:
            self.compare_tracks(*tracks)
        elif metadata:
            self.script.exit(1,'One of tracks was a metadata file')
        else:
            self.script.exit(1,'Requires two directory or file arguments')

class ConvertCommand(MusaCommand):
    def __init__(self,script):
        MusaCommand.__init__(self,script,'convert','Transcode file formats')

        self.parser.add_argument('-t','--threads', type=int, default=4,help='Number of transcoder threads to use')
        self.parser.add_argument('-m','--metadata', action='store_true', help='Copy album metadata')
        self.parser.add_argument('-y','--dry-run', action='store_true', help='Only show which tracks would have been transcoded')
        self.parser.add_argument('-f','--overwrite', action='store_true', help='Overwrite existing target files')
        self.parser.add_argument('-c','--codec', help='Destination file format for tree mode')
        self.parser.add_argument('paths', metavar='path', nargs='*', help='Paths to process')

    def enqueue(self,src,dst):
        """
        Enqueue tracks to trascode and mark track metadata for copying
        """
        if not isinstance(src,Track) or not isinstance(dst,Track):
            self.script.exit(1,'BUG: enqueue parameters must be Track objects')

        src_album = Album(os.path.dirname(src.path))
        dst_album = Album(os.path.dirname(dst.path))

        if src_album.path not in self.metadata_paths_to_copy.keys():
            self.metadata_paths_to_copy[src_album.path] = (src_album,dst_album)

        if os.path.isfile(dst.path) and not self.overwrite:
            return

        try:
            self.transcoder.enqueue(src,dst)
        except TranscoderError,emsg:
            self.script.exit(1,emsg)

    def parse_target_relative_path(self,src,dst=None,codec=None):
        if not isinstance(src,Track):
            self.script.exit(1,'BUG in parse_target_relative_path: src must be Track object')

        if codec is not None:
            prefix = self.prefixes.match_extension(codec,match_existing=True)
            if prefix is None:
                self.prefixes.match_extension(codec,match_existing=False)
        elif dst is not None:
            prefix = self.prefixes.match(dst.path,match_existing=True)
            if prefix is None:
                prefix = self.prefixes.match(dst.path,match_existing=True)
        else:
            raise MusaScriptError('BUG in parse_target_relative_path: Both dst and codec were None')

        if prefix is None:
            raise MusaScriptError('Could not resolve target path')

        codec = prefix.extensions[0]
        dst_relpath = '%s.%s' % (os.path.splitext(src.relative_path)[0],codec)
        return Track(os.path.join(prefix.path,dst_relpath))

    def transcode(self,src,dst=None,codec=None):
        if isinstance(src,Tree) and isinstance(dst,Tree):
            for track in src:
                dst_track = self.parse_target_relative_path(track,dst,codec)
                self.enqueue(track,dst_track)

        elif isinstance(src,Track) and (isinstance(dst,Tree) or isinstance(dst,Track)):
            dst_track = self.parse_target_relative_path(src,dst,codec)
            self.enqueue(src,dst_track)

        elif isinstance(src,Track) and dst is None:
            dst_track = self.parse_target_relative_path(src,codec=codec)
            self.enqueue(src,dst_track)

        else:
            self.script.exit(1,'Unsupported transcode arguments')

    def copy_metadata(self,dry_run=False):
        for src_path,albums in self.metadata_paths_to_copy.items():
            src_album,dst_album = albums
            self.log.debug('metadata: %s' % dst_album.path)
            src_album.copy_metadata(dst_album)

    def parse_args(self,args):
        trees,tracks,metadata = MusaCommand.parse_args(self,args)

        track_count = sum(len(d.files) for d in trees) + len(tracks)
        if not track_count:
            self.script.exit(1,'No music files detected')

        self.transcoder = MusaTranscoder(args.threads,args.overwrite,args.dry_run)
        self.overwrite = args.overwrite

        self.metadata_paths_to_copy = {}
        if args.codec is not None:
            for tree in trees:
                for track in tree:
                    self.transcode(track,codec=args.codec)
            for track in tracks:
                self.transcode(track,codec=args.codec)

        elif len(trees)==2:
            self.transcode(*trees)

        elif len(tracks)==2:
            self.transcode(*tracks)

        if len(self.transcoder):
            self.transcoder.run()
        else:
            self.script.error('Nothing to transcode')

        if args.metadata:
            self.copy_metadata(args.dry_run)

class SyncCommand(MusaCommand):
    def __init__(self,script):
        MusaCommand.__init__(self,script,'sync','Copy tags, files and trees')
        self.parser.add_argument('-t','--threads', type=int, default=4,help='Number of sync threads to use')
        self.parser.add_argument('paths', metavar='path', nargs='*',help='Paths to process')

    def enqueue(self,target):
        self.sync.enqueue(target)

    def parse_args(self,args):
        MusaCommand.parse_args(self,args,skip_targets = None)

        self.sync = SyncManager()

        for arg in args.paths:
            target = self.sync.parse_target(arg)
            self.enqueue(target)

        if len(self.sync):
            self.sync.run()
        else:
            self.script.exit(1,'No sync targets found')

class TagsCommand(MusaCommand):
    def __init__(self,script):
        MusaCommand.__init__(self,script,'tags','Manage music file tags', mode_flags=['set','clear','delete','edit','input_file'] )

        self.parser.add_argument('-s','--set',action='append', help='Set tag from value (tag=value)')
        self.parser.add_argument('-d','--delete',action='append', help='Delete tag')
        self.parser.add_argument('-C','--clear',action='store_true', help='Clear all tags')
        self.parser.add_argument('-e','--edit',action='store_true', help='Edit tags in external editor')
        self.parser.add_argument('-l','--list',action='store_true', help='List tags in given files')
        self.parser.add_argument('-p','--print-path',action='store_true', help='Print file path before tags')
        self.parser.add_argument('-r','--print-raw',action='store_true', help='Print raw tag values')
        self.parser.add_argument('-x','--xml',action='store_true', help='XML output')
        self.parser.add_argument('-P','--path-format', help='String format for --print-path flag')
        self.parser.add_argument('-i','--input-file',type=argparse.FileType('r'), help='Set new tags from input file')
        self.parser.add_argument('paths', metavar='path', nargs='*', help='Paths to process')

        self.xmltree = XMLTrackTree()

    def print_tags(self,track,print_path=False,path_format=None,xml=False):
        path_format = path_format is not None and path_format or '# %s'
        tags = self.get_tags(track)
        if tags is None:
            return
        if xml:
            self.xmltree.append(tags.as_xml())
        else:
            if print_path:
                self.message(path_format % track.path)
            for k,v in tags.items():
                self.message('%s %s' % (k,v))

    def edit_tags(self,track):
        track_tags = self.get_tags(track)
        if track_tags is None:
            return None
        new_tags = self.script.edit_tags(track_tags.as_dict())
        if new_tags != track_tags.as_dict():
            try:
                if track_tags.replace_tags(new_tags):
                    track_tags.save()
            except TagError,emsg:
                self.script.exit(1, 'Error saving tags to %s: %s' % (track.path,emsg) )

    def remove_tags(self,track,tags):
        track_tags = self.get_tags(track)
        if track_tags is None:
            return None
        try:
            if track_tags.remove_tags(tags):
                track_tags.save()
        except TagError,emsg:
            self.script.exit(1, 'Error removing tags from %s: %s' % (track.path,emsg) )

    def clear_tags(self,track):
        track_tags = self.get_tags(track)
        if track_tags is None:
            return None
        try:
            track_tags.clear_tags()
        except TagError,emsg:
            self.script.exit(1, 'Error removing tags from %s: %s' % (track.path,emsg) )

    def update_tags(self,track,tags):
        track_tags = self.get_tags(track)
        if track_tags is None:
            return None
        try:
            if track_tags.update_tags(tags):
                track_tags.save()
        except TagError,emsg:
            self.script.exit(1, 'Error saving tags to %s: %s' % (track.path,emsg) )

    def parse_args(self,args):
        trees,tracks,metadata = MusaCommand.parse_args(self,args)

        if args.path_format and not args.print_path:
            # If path format is given, set print_path on as well
            args.print_path = True

        track_count = sum(len(d.files) for d in trees) + len(tracks)
        if not track_count:
            self.script.exit(1,'No music files detected')

        if args.clear:
            self.process_tracks(trees,tracks,self.clear_tags)

        if args.delete:
            tags = args.delete
            self.process_tracks(trees,tracks,self.remove_tags,tags=tags)

        if args.set:
            tags = dict(map(lambda v: v.split('=',1), args.set))
            self.process_tracks(trees,tracks,self.update_tags,tags=tags)

        if args.input_file:
            try:
                tags = self.read_input_to_dict(args.input_file)
            except MusaScriptError,emsg:
                self.script.exit(1,str(emsg).strip())
            self.process_tracks(trees,tracks,self.update_tags,tags=tags)


        if args.edit:
            self.process_tracks(trees,tracks,self.edit_tags)

        # Finally, allow listing tags even if we were editing them earlier
        if args.list or not self.selected_mode_flags:
            self.process_tracks(trees,tracks,self.print_tags,
                print_path=args.print_path,
                path_format=args.path_format,
                xml=args.xml
            )

            if args.xml:
                self.message(self.xmltree.tostring())

class TreeCommand(MusaCommand):
    def __init__(self,script):
        MusaCommand.__init__(self,script,'tree','Manage music trees')

        self.parser.add_argument('-l','--list',action='store_true', help='List trees or files')
        self.parser.add_argument('paths', metavar='path', nargs='*', help='Files to process')

    def list_trees(self,trees):
        for tree in trees:
            self.message('%s: %d music files' % (tree.relative_path(),len(tree)))
            for album in tree.as_albums():
                print album.path

    def parse_args(self,args):
        trees,tracks,metadata = MusaCommand.parse_args(self,args)

        track_count = sum(len(d.files) for d in trees) + len(tracks)
        if not track_count:
            self.script.exit(1,'No music files detected')

        if tracks:
            self.script.exit(1,'File arguments are not accepted for tree commands')
        if not trees:
            self.script.exit(1,'No directory paths detected')

        if args.list:
            self.list_trees(trees)

script = MusaScript()
AlbumArtCommand(script)
CompareCommand(script)
ConvertCommand(script)
SyncCommand(script)
TagsCommand(script)
TreeCommand(script)
args = script.parse_args()

command = script.commands[args.command]
command.parse_args(args)

