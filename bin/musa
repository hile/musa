#!/usr/bin/env python
# coding=utf-8
"""
Music tagging and management tool
"""

import os
import sys
import shutil
import argparse

from musa import normalized,MusaError
from musa.cli import MusaScript, MusaCommand, MusaScriptError
from musa.tree import Tree, Album, Track, TreeError
from musa.tags import TagError
from musa.tags.xmltag import XMLTrackTree, XMLTagError

from musa.formats import match_metadata
from musa.metadata import CoverArt
from musa.playlist import m3uPlaylist, m3uPlaylistDirectory, PlaylistError
from musa.tags.albumart import AlbumArt, AlbumArtError

from musa.sync import SyncManager, SyncError
from musa.transcoder import MusaTranscoder, TranscoderError


class AlbumArtCommand(MusaCommand):

    """AlbumArtCommand

    Embed or extract albumart objects in supported audio files

    """

    def __init__(self, script):
        name = 'albumart'
        description = 'Manage music file album art'
        mode_flags = []
        MusaCommand.__init__(self, script, name, description, mode_flags)
        self.parser.add_argument('-e', '--embed', action='store_true', help='Embed artwork file')
        self.parser.add_argument('-x', '--extract', action='store_true', help='Extract artwork file')
        self.parser.add_argument('-X', '--extract-missing', action='store_true', help='Extract missing artwork file')
        self.parser.add_argument('-i', '--info', action='store_true', help='Artwork files info')
        self.parser.add_argument('-u', '--url', help='Fetch artwork from given url')
        self.parser.add_argument('paths', metavar='path', nargs='*', help='Paths to process')

    def show_info(self, target):
        if isinstance(target, Track):
            tags = self.get_tags(target)
            if tags is None or not tags.supports_albumart:
                return
            try:
                albumart = tags.albumart
            except AlbumArtError, emsg:
                return
            self.message('%s: %s' % (target.path, albumart))

        elif isinstance(target, Tree):
            for album in target.as_albums():
                album.load()
                for m in album.metadata:
                    if isinstance(m, CoverArt):
                        self.print_coverart_info(m)
                    else:
                        self.message(m)

    def print_coverart_info(self, coverart):
        albumart = AlbumArt(coverart.path)
        self.message('%s: %s' % (coverart.path, albumart))

    def embed(self,target,albumart=None):
        if isinstance(target, Tree):
            albums = target.as_albums()

            if not albums:
                self.script.exit(1, 'No albums found from path %s' % target.path)
            if len(albums) > 1 and albumart is not None:
                self.script.exit(1, 'Given albumart can only embedded to single album tree targets')

            album = albums[0]

            if albumart is None:
                albumart = album.albumart
            if albumart is None:
                self.script.exit('No albumart found from album %s' % album.path)
                return

            for track in album:
                tags = track.tags
                if tags is None or not tags.supports_albumart:
                    self.log.debug('albumart not supported: %s' % track.path)
                    continue
                self.log.debug('embed: %s' % track.path)
                tags.set_albumart(albumart)
                tags.save()

        elif isinstance(target, Track):
            if albumart is None:
                track_album = Album(os.path.dirname(target.path))
                albumart = track_album.albumart
            if albumart is None:
                return
            tags = target.tags
            if tags is None or not tags.supports_albumart:
                self.log.debug('albumart not supported: %s' % target.path)
                return
            self.log.debug('embed: %s' % target.path)
            tags.set_albumart(albumart)
            tags.save()

    def extract(self,target,overwrite=True):
        if isinstance(target, Tree):
            albums = target.as_albums()
            if not albums:
                self.script.exit(1, 'No albums found from path %s' % target.path)
            for album in albums:
                track = album[0]
                tags = track.tags
                if tags is None:
                    self.script.error('No tags in %s' % track.path)
                    continue
                if not tags.albumart:
                    self.script.error('No album art in %s' % track.path)
                    continue

                albumart_path = os.path.join(os.path.dirname(track.path), 'artwork.jpg')

                if not overwrite and os.path.isfile(albumart_path):
                    self.log.debug('Skip existing: %s' % albumart_path)
                else:
                    try:
                        tags.albumart.save(albumart_path)
                        self.log.debug('Saving %s: %s' % (albumart_path, tags.albumart))
                    except TagError, emsg:
                        self.log.debug('Error saving %s: %s' % (albumart_path, emsg))

        elif isinstance(target, Track):
            tags = target.tags
            if tags is None:
                self.script.error('No tags in %s' % target.path)
                return
            if not tags.albumart:
                self.script.error('No album art in %s' % target.path)
                return

            albumart_path = os.path.join(os.path.dirname(target.path), 'artwork.jpg')

            if not overwrite and os.path.isfile(albumart_path):
                self.log.debug('Skip existing: %s' % albumart_path)
            else:
                try:
                    tags.albumart.save(albumart_path)
                    self.log.debug('Saving %s: %s' % (albumart_path, tags.albumart))
                except TagError, emsg:
                    self.log.debug('Error saving %s: %s' % (albumart_path, emsg))

    def parse_args(self, args):
        trees, tracks, metadata = MusaCommand.parse_args(self, args)

        if args.info:
            for m in metadata:
                if not isinstance(m, CoverArt):
                    continue
                self.print_coverart_info(m)

            for tree in trees:
                self.show_info(tree)

            for track in tracks:
                self.show_info(track)

        if args.url:
            albumart = AlbumArt()
            try:
                albumart.fetch(args.url)
            except AlbumArtError, emsg:
                self.script.exit(1, 'Error fetching albumart: %s' % emsg)
            for target in trees:
                albumart.save(target.path)
        else:
            albumart = None

        if args.embed:
            for tree in trees:
                self.embed(tree, albumart)
            for track in tracks:
                self.embed(track, albumart)

        if args.extract or args.extract_missing:
            overwrite = args.extract_missing == False
            for tree in trees:
                self.extract(tree, overwrite=overwrite)
            for track in tracks:
                self.extract(track, overwrite=overwrite)


class CleanupCommand(MusaCommand):

    def __init__(self, script):
        name = 'cleanup'
        description = 'Remove unwanted metadata files from tree'
        mode_flags = []
        MusaCommand.__init__(self, script, name, description, mode_flags)
        self.parser.add_argument('-y', '--dry-run', action='store_true', help='Only show files to be removed')
        self.parser.add_argument('paths', metavar='path', nargs='*', help='Paths to process')

    def cleanup_tree(self, tree, dry_run):
        if not isinstance(tree, Tree):
            self.script.exit(1, 'BUG: cleanup_tree argument not Tree instance')

        for path in tree.invalid_paths:
            metadata = match_metadata(path)
            if metadata:
                if not metadata.removable:
                    continue
                self.log.debug('Unwanted metadata %s: %s' % (metadata, path))
            else:
                self.log.debug('Unknown file type: %s' % path)
            try:
                os.unlink(path)
            except OSError, (ecode, emsg):
                self.log.message('Error removing %s: %s' % (path, emsg))

        # Reload tree to get empty trees
        self.log.debug('Reloading tree to process empty directories')
        tree.load()
        for empty in tree.empty_dirs:
            tree.remove_empty_path(empty)

    def parse_args(self, args):
        trees, tracks, metadata = MusaCommand.parse_args(self, args)

        if not len(trees):
            self.script.exit(1, 'Cleanup command only valid for trees')

        for tree in trees:
            self.cleanup_tree(tree, dry_run=args.dry_run)



class CompareCommand(MusaCommand):

    def __init__(self, script):
        name = 'compare'
        description = 'Compare music files'
        mode_flags = []
        MusaCommand.__init__(self, script, name, description, mode_flags)
        self.parser.add_argument('paths', metavar='path', nargs='*', help='Paths to process')

    def compare_trees(self, src, dst):
        src_track_paths = [x.relative_path.no_ext for x in src]
        dst_track_paths = [x.relative_path.no_ext for x in dst]
        if src_track_paths != dst_track_paths:
            script.message('Filename mismatch')
            for s in src_tracks:
                script.message(type(s.relative_path), s.relative_path.no_ext)
        for track in src:
            if track.relative_path.no_ext not in dst_track_paths:
                script.message('%s: missing %s' % (dst.relative_path, track.relative_path.no_ext))
                continue

    def compare_tracks(self, src, dst):
        if isinstance(src, basestring):
            try:
                src = Track(src)
            except TreeError, emsg:
                self.script.exit(1, emsg)
        if isinstance(src, basestring):
            try:
                dst = Track(dst)
            except TreeError, emsg:
                self.script.exit(1, emsg)
        self.log.debug('Comparing %s to %s' % (src.relative_path, dst.relative_path))
        src_tags = src.tags
        dst_tags = dst.tags

        for tag in sorted(src_tags.keys()):
            if tag not in dst_tags.keys():
                self.script.error('%s: missing %s' % (dst.relative_path, tag))

        for tag in sorted(dst_tags.keys()):
            if tag not in src_tags.keys():
                self.script.error('%s: missing %s' % (src.relative_path, tag))

        for tag in sorted(src_tags.keys()):
            if tag not in dst_tags.keys():
                continue
            if src_tags[tag] != dst_tags[tag]:
                self.script.error('tag %s: %s != %s' % (tag, src_tags[tag], dst_tags[tag]))

    def parse_args(self, args):
        trees, tracks, metadata = MusaCommand.parse_args(self, args)

        if trees and tracks:
            self.script.exit(1, "Can't compare trees to tracks")

        if trees and len(trees) == 2:
            self.compare_trees(*trees)
        elif tracks and len(tracks) == 2:
            self.compare_tracks(*tracks)
        elif metadata:
            self.script.exit(1, 'One of tracks was a metadata file')
        else:
            self.script.exit(1, 'Requires two directory or file arguments')


class CodecCommand(MusaCommand):

    def __init__(self, script):
        name = 'codecs'
        description = 'Configure codec command stored to database'
        mode_flags = []
        MusaCommand.__init__(self, script, name, description, mode_flags)
        self.parser.add_argument('-l', '--list', action='store_true', help='List configuration settings')
        self.parser.add_argument('--register-tester', help='Register tester command to specified codec')
        self.parser.add_argument('--unregister-tester', help='Unregister tester command to specified codec')
        self.parser.add_argument('names', nargs='*', help='Codec names to match')

    def parse_args(self, args):
        MusaCommand.parse_args(self, args, skip_targets=True)

        if args.register_tester:
            if len(args.names) != 1:
                script.error(1,'Only one valid codec name can be provided with --register-tester command')

            try:
                codec = self.script.db.codecs[args.names[0]]
                codec.register_formattester(self.script.db.session,args.register_tester)
            except MusaError,emsg:
                script.exit(1,emsg)

        if args.unregister_tester:
            if len(args.names) != 1:
                script.error(1,'Only one valid codec name can be provided with --unregister-tester command')

            try:
                codec = self.script.db.codecs[args.names[0]]
                codec.unregister_formattester(self.script.db.session,args.unregister_tester)
            except MusaError,emsg:
                script.exit(1,emsg)

        if args.list:
            for name, codec in self.script.db.codecs.items():
                if args.names and name not in args.names:
                    continue
                self.message('%s' % name)
                self.message('  Description: %s' % codec.description)
                self.message('  Extensions:  %s' % ','.join(e.extension for e in codec.extensions))

                if codec.encoders:
                    self.message('  Encoders:')
                    for encoder in codec.encoders:
                        script.message('    %s' % encoder)

                if codec.decoders:
                    self.message('  Decoders:')
                    for decoder in codec.decoders:
                        script.message('    %s' % decoder)

                if codec.formattesters:
                    self.message('   Testers:')
                    for tester in codec.formattesters:
                        script.message('    %s' % tester)

class ConfigCommand(MusaCommand):

    def __init__(self, script):
        name = 'config'
        description = 'Configure musa settings'
        mode_flags = []
        MusaCommand.__init__(self, script, name, description, mode_flags)

        self.parser.add_argument('-t', '--threads', type=int, help='Number of threads to use')
        self.parser.add_argument('-c', '--default-codec', help='Default codec to use')
        self.parser.add_argument('-l', '--list', action='store_true', help='List configuration settings')
        self.parser.add_argument('names', nargs='*', help='Sync targets to process')

    def list_config_items(self):
        for k, v in self.script.db.items():
            self.message('%s=%s' % (k, v))

    def parse_args(self, args):
        MusaCommand.parse_args(self, args, skip_targets=True)

        if args.default_codec:
            if self.get_codec(args.default_codec) is None:
                self.script.exit(1, 'Error setting default codec: unknown codec %s' % args.default_codec)
            self.script.db.set('default_codec', args.default_codec)

        if args.threads:
            self.script.db.set('threads', args.threads)

        if args.list:
            self.list_config_items()


class ConvertCommand(MusaCommand):

    def __init__(self, script):
        name = 'convert'
        description = 'Transcode audio file formats'
        mode_flags = []
        MusaCommand.__init__(self, script, name, description, mode_flags)

        self.parser.add_argument('-t', '--threads', type=int, help='Number of transcoder threads to use')
        self.parser.add_argument('-m', '--metadata', action='store_true', help='Copy album metadata')
        self.parser.add_argument('-y', '--dry-run', action='store_true', help='Only show which tracks would have been transcoded')
        self.parser.add_argument('-f', '--overwrite', action='store_true', help='Overwrite existing target files')
        self.parser.add_argument('-p', '--prefix', help='Target file relative path prefix')
        self.parser.add_argument('-c', '--codecs', help='Destination codecs for tree mode')
        self.parser.add_argument('paths', metavar='path', nargs='*', help='Paths to process')

    def enqueue(self, src, dst):
        """
        Enqueue tracks to trascode and mark track metadata for copying
        """
        if not isinstance(src, Track) or not isinstance(dst, Track):
            self.script.exit(1, 'BUG: enqueue parameters must be Track objects')

        src_album = Album(os.path.dirname(src.path))
        dst_album = Album(os.path.dirname(dst.path))

        if src_album.path not in self.metadata_paths_to_copy.keys():
            self.metadata_paths_to_copy[src_album.path] = (src_album, dst_album)

        if os.path.isfile(dst.path) and not self.overwrite:
            self.log.debug('File exists: %s' % dst.path)
            return

        try:
            self.transcoder.enqueue(src, dst)
        except TranscoderError, emsg:
            self.script.exit(1, emsg)

    def parse_target_relative_path(self,src,dst=None,prefix_path=None,codec=None):
        if not isinstance(src, Track):
            self.script.exit(1, 'BUG in parse_target_relative_path: src must be Track object')

        if codec is not None:
            prefix = self.prefixes.match_extension(codec, match_existing=True)
            if prefix is None:
                raise MusaScriptError('No tree prefix matching codec %s found' % codec)

        elif dst is not None:
            prefix = self.prefixes.match(dst.path, match_existing=True)
            if prefix is None:
                prefix = self.prefixes.match(dst.path, match_existing=False)
            if prefix is None:
                raise MusaScriptError('Error finding prefix matching path %s' % dst)

        else:
            raise MusaScriptError('BUG in parse_target_relative_path: Both dst and codec were None')

        extension = prefix.extensions[0]
        if prefix_path is None:
            prefix_path = prefix.path

        if src.relative_path.startswith(os.sep):
            # Could not parse relative path for source: encode to src directory
            prefix_path = os.path.dirname(os.path.realpath(src.path))
            dst_relpath = '%s.%s' % (os.path.splitext(src.path)[0], extension)
        else:
            # Encode to relative path in prefix directory
            dst_relpath = '%s.%s' % (os.path.splitext(src.relative_path)[0], extension)

        return Track(os.path.join(prefix_path, dst_relpath))

    def transcode(self, src, dst=None, prefix_path=None, codec=None):
        try:
            if isinstance(src, Tree) and isinstance(dst, Tree):
                for track in src:
                    dst_track = self.parse_target_relative_path(track, dst, prefix_path, codec)
                    self.enqueue(track, dst_track)

            elif isinstance(src, Track) and (isinstance(dst, Tree) or isinstance(dst, Track)):
                dst_track = self.parse_target_relative_path(src, dst, prefix_path, codec)
                self.enqueue(src, dst_track)

            elif isinstance(src, Track) and dst is None:
                dst_track = self.parse_target_relative_path(src, prefix_path=prefix_path, codec=codec)
                self.enqueue(src, dst_track)

            else:
                self.script.exit(1, 'Unsupported transcode arguments')
        except MusaScriptError,emsg:
            self.script.exit(1,emsg)

    def copy_metadata(self,dry_run=False):
        for src_path, albums in self.metadata_paths_to_copy.items():
            src_album, dst_album = albums
            self.log.debug('metadata: %s' % dst_album.path)
            src_album.copy_metadata(dst_album)

    def parse_args(self, args):
        trees, tracks, metadata = MusaCommand.parse_args(self, args)

        track_count = sum(len(d.files) for d in trees) + len(tracks)
        if not track_count:
            self.script.exit(1, 'No music files detected')

        threads = args.threads is not None and args.threads or self.script.db.get('threads')

        self.transcoder = MusaTranscoder(threads, args.overwrite, args.dry_run)
        self.overwrite = args.overwrite

        self.metadata_paths_to_copy = {}
        if args.codecs is not None:
            for codec in args.codecs.split(','):
                for tree in trees:
                    for track in tree:
                        self.transcode(track, prefix_path=args.prefix, codec=codec)
                for track in tracks:
                    self.transcode(track, prefix_path=args.prefix, codec=codec)

        elif len(trees) == 2:
            self.transcode(*trees,prefix_path=args.prefix)

        elif len(tracks) == 2:
            self.transcode(*tracks,prefix_path=args.prefix)

        if len(self.transcoder):
            self.transcoder.run()
        else:
            self.script.error('Nothing to transcode')

        if args.metadata:
            self.copy_metadata(args.dry_run)


class DatabaseCommand(MusaCommand):

    def __init__(self, script):
        name = 'db'
        description = 'Manage music file database'
        mode_flags = []
        MusaCommand.__init__(self, script, name, description, mode_flags)

        self.parser.add_argument('-l', '--list', action='store_true', help='List registered trees')
        self.parser.add_argument('-t', '--list-tracks', action='store_true', help='List tracks in trees')
        self.parser.add_argument('-m', '--match', help='Match files based on arguments')
        self.parser.add_argument('-i', '--info', action='store_true', help='List tags for matched files')
        self.parser.add_argument('-b', '--update', action='store_true', help='Update database')
        self.parser.add_argument('-r', '--register', action='store_true', help='Register trees')
        self.parser.add_argument('-u', '--unregister', action='store_true', help='Unregister trees')
        self.parser.add_argument('trees', nargs='*', help='Tree paths to process')

    def parse_args(self, args):
        MusaCommand.parse_args(self, args, skip_targets=True)

        if args.register:
            for dbt in args.trees:
                try:
                    self.script.db.register_tree(dbt)
                except MusaError,emsg:
                    self.script.exit(1,emsg)

        elif args.unregister:
            for dbt in args.trees:
                self.script.db.unregister_tree(dbt)
            script.exit(0)

        if args.trees:
            trees = []
            for dbt in args.trees:
                entry = self.script.db.get_tree(dbt)
                if entry is None:
                    self.script.exit(1,'Path not registered: %s' % dbt)
                trees.append(entry)
        else:
            trees = self.script.db.trees

        if args.list:
            for dbt in self.script.db.trees:
                print 'Tree: %s' % dbt.path

        if args.list_tracks:
            for dbt in self.script.db.trees:
                print 'Tree: %s' % dbt.path
                for album in dbt.albums:
                    if album.relative_path:
                        print '  %s' % album.relative_path
                    for track in album.tracks:
                        print '    %s' % track.filename
                        for tag in track.tags:
                            print '      %s=%s' % (tag.tag,tag.value)

        if args.update:
            for dbt in trees:
                self.script.log.debug('Updating database entries for %s' % dbt.path)
                dbt.update(self.script.db.session,Tree(dbt.path))

        elif args.match:
            for dbt in trees:
                tracks = dbt.match(self.script.db.session,args.match)
                if len(tracks):
                    self.log.info('### %d matches in %s ###' % (len(tracks,), dbt))
                for track in tracks:
                    self.script.message(track.relative_path)
                    if args.info:
                        for t in track.tags:
                            self.script.message('%16s %s' % (t.tag, t.value))

        elif args.info:
            for dbt in trees:
                script.message(dbt)
                script.message('Albums: %s' % dbt.album_count(self.script.db.session))
                script.message('Songs: %s' % dbt.song_count(self.script.db.session))
                script.message('Tags: %s' % dbt.tag_count(self.script.db.session))


class PlaylistCommand(MusaCommand):

    def __init__(self, script):
        name = 'playlist'
        description = 'Manipulate playlists'
        mode_flags = []
        PLAYLIST_DIRECTORY = os.path.expanduser('~/Music/Playlists')
        MusaCommand.__init__(self, script, name, description, mode_flags)
        self.parser.add_argument('-l', '--list', action='store_true', help='List playlist songs')
        self.parser.add_argument('-b', '--update', action='store_true', help='Update registered playlist trees')
        self.parser.add_argument('-r', '--register', action='store_true', help='Register playlist trees')
        self.parser.add_argument('-u', '--unregister', action='store_true', help='Unregister playlist trees')
        self.parser.add_argument('paths', nargs='*', help='Tree paths to process')

    def parse_args(self, args):
        MusaCommand.parse_args(self, args, skip_targets=True)

        if args.register:
            for path in args.paths:
                try:
                    self.script.db.register_playlist_source(path)
                except MusaError,emsg:
                    script.exit(1,emsg)
            script.exit(0)

        elif args.unregister:
            for path in args.paths:
                try:
                    self.script.db.unregister_playlist_source(path)
                except MusaError,emsg:
                    script.exit(1,emsg)
            script.exit(0)

        if args.paths:
            sources = []
            for path in args.paths:
                entry = self.script.db.get_playlist_source(path)
                if entry is None:
                    self.script.exit(1,'Path not registered: %s' % path)
                sources.append(entry)
        else:
            sources = self.script.db.playlist_sources

        if args.update:
            for source in sources:
                m3u_directory = m3uPlaylistDirectory(source.path)
                script.log.debug('Updating source: %s' % source.path)
                source.update(self.script.db.session,m3u_directory)

        if args.list:
            for source in sources:
                script.log.debug('Playlist source: %s' % source.path)
                for playlist in source.playlists:
                    print playlist
                    for path in playlist.tracks:
                        print '  %s' % path


class SyncCommand(MusaCommand):

    def __init__(self, script):
        name = 'sync'
        description = 'Synchronize files and trees'
        mode_flags = []
        MusaCommand.__init__(self, script, name, description, mode_flags)
        self.parser.add_argument('-d', '--directories', action='store_true', help='Sync directories, not configured targets')
        self.parser.add_argument('-l', '--list', action='store_true',help='List configured sync targets')
        self.parser.add_argument('-r', '--rename', help='Directory sync target filesystem rename callback')
        self.parser.add_argument('-D', '--delete', action='store_true', help='Remove unknown files from target')
        self.parser.add_argument('-t', '--threads', type=int, help='Number of sync threads to use')
        self.parser.add_argument('paths', metavar='path', nargs='*', help='Paths to process')

    def parse_args(self, args):
        MusaCommand.parse_args(self, args, skip_targets=True)
        self.manager = SyncManager(threads=args.threads, delete=args.delete,debug=args.debug)

        if args.list:
            for name, settings in self.script.db.sync.items():
                if args.paths and name not in args.paths:
                    continue
                self.message('%s' % name)
                self.message('  Type:        %s' % settings['type'])
                self.message('  Source:      %s' % settings['src'])
                self.message('  Destination: %s' % settings['dst'])
                self.message('  Flags:       %s' % settings['flags'])
            script.exit(0)

        if args.directories:
            if len([d for d in args.paths if os.path.isdir(d)]) != 2:
                self.script.exit(1, 'Directory sync requires two existing directory paths')
            src = Tree(args.paths[0])
            dst = Tree(args.paths[1])
            self.manager.enqueue({'type': 'directory','src':src,'dst':dst,'rename':args.rename})

        elif args.paths:
            for arg in args.paths:
                target = self.manager.parse_target(arg)
                if not target:
                    self.script.exit(1, 'No such target: %s' % arg)
                self.manager.enqueue(target)
        else:
            for target in self.manager.db.sync.default_targets:
                self.manager.enqueue(self.manager.parse_target(target))

        if len(self.manager):
            self.manager.run()
        else:
            self.script.exit(1, 'No sync targets found')


class TagsCommand(MusaCommand):

    def __init__(self, script):
        name = 'tags'
        description = 'Manage music file tags'
        mode_flags = ['set', 'clear', 'delete', 'edit', 'from_path', 'input_file']
        MusaCommand.__init__(self, script, name, description, mode_flags)

        self.parser.add_argument('-l', '--list', action='store_true', help='List tags in given files')
        self.parser.add_argument('-g', '--get', action='append', help='Get listed tags')
        self.parser.add_argument('-s', '--set', action='append', help='Set tag from value (tag=value)')
        self.parser.add_argument('-i', '--input-file', type=argparse.FileType('r'), help='Set new tags from input file')
        self.parser.add_argument('-e', '--edit', action='store_true', help='Edit tags in external editor')
        self.parser.add_argument('-f', '--from-path', action='store_true', help='Guess tags to set from file path')
        self.parser.add_argument('-d', '--delete', action='append', help='Delete tag')
        self.parser.add_argument('-C', '--clear', action='store_true', help='Clear all tags')
        self.parser.add_argument('-p', '--print-path', action='store_true', help='Print file path before tags')
        self.parser.add_argument('-r', '--print-raw', action='store_true', help='Print raw tag values')
        self.parser.add_argument('-x', '--xml', action='store_true', help='XML output')
        self.parser.add_argument('-j', '--json', action='store_true', help='JSON output')
        self.parser.add_argument('-P', '--path-format', help='String format for --print-path flag')
        self.parser.add_argument('paths', metavar='path', nargs='*', help='Paths to process')

        self.xmltree = XMLTrackTree()

    def print_tags(self,track,print_path=False,path_format=None,raw_tags=False,xml=False,json=False,show_tags=[]):

        path_format = path_format is not None and path_format or '# %s'

        tags = self.get_tags(track)
        if tags is None:
            return

        if xml:
            self.xmltree.append(tags.as_xml())

        elif json:
            self.message(tags.to_json())

        elif raw_tags:
            if print_path:
                self.message(path_format % track.path)
            for k, v in tags.get_raw_tags():
                if show_tags and k not in show_tags:
                    continue
                self.message('%s %s' % (k, v))
        else:
            if print_path:
                self.message(path_format % track.path)
            for k, v in tags.items():
                if show_tags and k not in show_tags:
                    continue
                self.message('%s %s' % (k, v))

    def edit_tags(self, track):
        """
        Edit tags with external editor command
        """
        track_tags = self.get_tags(track)
        if track_tags is None:
            return None

        new_tags = self.script.edit_tags(track_tags.as_dict())
        if new_tags != track_tags.as_dict():
            try:
                if track_tags.replace_tags(new_tags):
                    track_tags.save()
                    db_track = self.script.db.get_track(track.path)
                    if db_track is not None:
                        db_track.update(self.script.db.session,track)
            except TagError, emsg:
                self.script.exit(1, 'Error saving tags to %s: %s' % (track.path, emsg))

    def remove_tags(self, track, tags):
        track_tags = self.get_tags(track)
        if track_tags is None:
            return None
        try:
            if track_tags.remove_tags(tags):
                track_tags.save()
                db_track = self.script.db.get_track(track.path)
                if db_track is not None:
                    db_track.update(self.script.db.session,track)

        except TagError, emsg:
            self.script.exit(1, 'Error removing tags from %s: %s' % (track.path, emsg))

    def clear_tags(self, track):
        """
        Clear all tags from track
        """
        track_tags = self.get_tags(track)
        if track_tags is None:
            return None
        try:
            track_tags.clear_tags()
            db_track = self.script.db.get_track(track.path)
            if db_track is not None:
                db_track.update(self.script.db.session,track)

        except TagError, emsg:
            self.script.exit(1, 'Error removing tags from %s: %s' % (track.path, emsg))

    def tags_from_path(self,track,tags={}):
        parts = normalized(track.relative_path).split(os.sep)
        if len(parts) >= 3:
            tags['album_artist'] = parts[-3]
            tags['artist'] = parts[-3]
            tags['album'] = parts[-2]
            tracknumber, title = track.tracknumber_and_title
            tags['title'] = title
            if tracknumber is not None:
                tags['tracknumber'] = tracknumber
                tags['totaltracks'] = len(track.album)
        self.update_tags(track, tags)

    def update_tags(self, track, tags):
        track_tags = self.get_tags(track)
        if track_tags is None:
            return None
        try:
            if track_tags.update_tags(tags):
                track_tags.save()
                db_track = self.script.db.get_track(track.path)
                if db_track is not None:
                    db_track.update(self.script.db.session,track)
        except TagError, emsg:
            self.script.exit(1, 'Error saving tags to %s: %s' % (track.path, emsg))

    def parse_args(self, args):
        trees, tracks, metadata = MusaCommand.parse_args(self, args)

        if args.xml and args.json:
            self.script.exit(1,'Flags --xml and --json are mutually exclusive')

        if args.path_format and not args.print_path:
            # If path format is given, set print_path on as well
            args.print_path = True

        track_count = sum(len(d.files) for d in trees) + len(tracks)
        if not track_count:
            self.script.exit(1, 'No music files detected')

        if args.clear:
            self.process_tracks(trees, tracks, self.clear_tags)

        if args.from_path:
            self.process_tracks(trees, tracks, self.tags_from_path)

        if args.delete:
            tags = args.delete
            self.process_tracks(trees, tracks, self.remove_tags, tags=tags)

        if args.set:
            try:
                tags = dict(map(lambda v: v.split('=', 1), args.set))
            except ValueError:
                self.script.exit('Invalid arguments to --set flag: %s' % args.set)
            self.process_tracks(trees, tracks, self.update_tags, tags=tags)

        if args.input_file:
            try:
                tags = self.read_input_to_dict(args.input_file)
            except MusaScriptError, emsg:
                self.script.exit(1, str(emsg).strip())
            self.process_tracks(trees, tracks, self.update_tags, tags=tags)

        if args.edit:
            self.process_tracks(trees, tracks, self.edit_tags)

        # Finally, allow listing tags even if we were editing them earlier
        if args.list or not self.selected_mode_flags:
            self.process_tracks(
                trees,
                tracks,
                self.print_tags,
                print_path=args.print_path,
                path_format=args.path_format,
                raw_tags=args.print_raw,
                xml=args.xml,
                json=args.json,
                show_tags=args.get,
            )

            if args.xml:
                self.message(self.xmltree.tostring())


script = MusaScript()
AlbumArtCommand(script)
CleanupCommand(script)
CodecCommand(script)
CompareCommand(script)
ConfigCommand(script)
ConvertCommand(script)
PlaylistCommand(script)
SyncCommand(script)
TagsCommand(script)
DatabaseCommand(script)
args = script.parse_args()

command = script.commands[args.command]
command.parse_args(args)
